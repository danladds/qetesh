/* EventManager.c generated by valac 0.22.1, the Vala compiler
 * generated from EventManager.vala, do not modify */

/*
 * EventManager.vala
 * 
 * Copyright 2014 Dan Ladds <Dan@el-topo.co.uk>
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 * 
 * 
 */

#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>


#define QETESH_TYPE_EVENT_MANAGER (qetesh_event_manager_get_type ())
#define QETESH_EVENT_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), QETESH_TYPE_EVENT_MANAGER, QeteshEventManager))
#define QETESH_EVENT_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), QETESH_TYPE_EVENT_MANAGER, QeteshEventManagerClass))
#define QETESH_IS_EVENT_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), QETESH_TYPE_EVENT_MANAGER))
#define QETESH_IS_EVENT_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), QETESH_TYPE_EVENT_MANAGER))
#define QETESH_EVENT_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), QETESH_TYPE_EVENT_MANAGER, QeteshEventManagerClass))

typedef struct _QeteshEventManager QeteshEventManager;
typedef struct _QeteshEventManagerClass QeteshEventManagerClass;
typedef struct _QeteshEventManagerPrivate QeteshEventManagerPrivate;

#define QETESH_TYPE_QEVENT (qetesh_qevent_get_type ())
#define QETESH_QEVENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), QETESH_TYPE_QEVENT, QeteshQEvent))
#define QETESH_QEVENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), QETESH_TYPE_QEVENT, QeteshQEventClass))
#define QETESH_IS_QEVENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), QETESH_TYPE_QEVENT))
#define QETESH_IS_QEVENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), QETESH_TYPE_QEVENT))
#define QETESH_QEVENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), QETESH_TYPE_QEVENT, QeteshQEventClass))

typedef struct _QeteshQEvent QeteshQEvent;
typedef struct _QeteshQEventClass QeteshQEventClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _qetesh_qevent_unref0(var) ((var == NULL) ? NULL : (var = (qetesh_qevent_unref (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))

struct _QeteshEventManager {
	GObject parent_instance;
	QeteshEventManagerPrivate * priv;
};

struct _QeteshEventManagerClass {
	GObjectClass parent_class;
};

struct _QeteshEventManagerPrivate {
	GeeConcurrentList* EventList;
};


static gpointer qetesh_event_manager_parent_class = NULL;

GType qetesh_event_manager_get_type (void) G_GNUC_CONST;
gpointer qetesh_qevent_ref (gpointer instance);
void qetesh_qevent_unref (gpointer instance);
GParamSpec* qetesh_param_spec_qevent (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void qetesh_value_set_qevent (GValue* value, gpointer v_object);
void qetesh_value_take_qevent (GValue* value, gpointer v_object);
gpointer qetesh_value_get_qevent (const GValue* value);
GType qetesh_qevent_get_type (void) G_GNUC_CONST;
#define QETESH_EVENT_MANAGER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), QETESH_TYPE_EVENT_MANAGER, QeteshEventManagerPrivate))
enum  {
	QETESH_EVENT_MANAGER_DUMMY_PROPERTY
};
QeteshEventManager* qetesh_event_manager_new (void);
QeteshEventManager* qetesh_event_manager_construct (GType object_type);
gchar* qetesh_event_manager_GetEventCode (QeteshEventManager* self);
const gchar* qetesh_qevent_get_ClientEventType (QeteshQEvent* self);
void qetesh_event_manager_RegisterEvent (QeteshEventManager* self, QeteshQEvent* ev, const gchar* clientId);
void qetesh_event_manager_CallEvents (QeteshEventManager* self, const gchar* clientId);
static void qetesh_event_manager_finalize (GObject* obj);


QeteshEventManager* qetesh_event_manager_construct (GType object_type) {
	QeteshEventManager * self = NULL;
	GeeConcurrentList* _tmp0_ = NULL;
	self = (QeteshEventManager*) g_object_new (object_type, NULL);
	_tmp0_ = gee_concurrent_list_new (QETESH_TYPE_QEVENT, (GBoxedCopyFunc) qetesh_qevent_ref, qetesh_qevent_unref, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->EventList);
	self->priv->EventList = _tmp0_;
	return self;
}


QeteshEventManager* qetesh_event_manager_new (void) {
	return qetesh_event_manager_construct (QETESH_TYPE_EVENT_MANAGER);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


gchar* qetesh_event_manager_GetEventCode (QeteshEventManager* self) {
	gchar* result = NULL;
	GString* code = NULL;
	GString* _tmp0_ = NULL;
	GString* _tmp16_ = NULL;
	const gchar* _tmp17_ = NULL;
	gchar* _tmp18_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_string_new ("");
	code = _tmp0_;
	{
		GeeConcurrentList* _ev_list = NULL;
		GeeConcurrentList* _tmp1_ = NULL;
		GeeConcurrentList* _tmp2_ = NULL;
		gint _ev_size = 0;
		GeeConcurrentList* _tmp3_ = NULL;
		gint _tmp4_ = 0;
		gint _tmp5_ = 0;
		gint _ev_index = 0;
		_tmp1_ = self->priv->EventList;
		_tmp2_ = _g_object_ref0 (_tmp1_);
		_ev_list = _tmp2_;
		_tmp3_ = _ev_list;
		_tmp4_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp3_);
		_tmp5_ = _tmp4_;
		_ev_size = _tmp5_;
		_ev_index = -1;
		while (TRUE) {
			gint _tmp6_ = 0;
			gint _tmp7_ = 0;
			gint _tmp8_ = 0;
			QeteshQEvent* ev = NULL;
			GeeConcurrentList* _tmp9_ = NULL;
			gint _tmp10_ = 0;
			gpointer _tmp11_ = NULL;
			GString* _tmp12_ = NULL;
			QeteshQEvent* _tmp13_ = NULL;
			const gchar* _tmp14_ = NULL;
			const gchar* _tmp15_ = NULL;
			_tmp6_ = _ev_index;
			_ev_index = _tmp6_ + 1;
			_tmp7_ = _ev_index;
			_tmp8_ = _ev_size;
			if (!(_tmp7_ < _tmp8_)) {
				break;
			}
			_tmp9_ = _ev_list;
			_tmp10_ = _ev_index;
			_tmp11_ = gee_abstract_list_get ((GeeAbstractList*) _tmp9_, _tmp10_);
			ev = (QeteshQEvent*) _tmp11_;
			_tmp12_ = code;
			_tmp13_ = ev;
			_tmp14_ = qetesh_qevent_get_ClientEventType (_tmp13_);
			_tmp15_ = _tmp14_;
			g_string_append (_tmp12_, _tmp15_);
			_qetesh_qevent_unref0 (ev);
		}
		_g_object_unref0 (_ev_list);
	}
	_tmp16_ = code;
	_tmp17_ = _tmp16_->str;
	_tmp18_ = g_strdup (_tmp17_);
	result = _tmp18_;
	_g_string_free0 (code);
	return result;
}


/**
* Register an event
* 
* If called with a clientID, the event will be registered for
* that client only. Otherwise it is registered for all clients
* 
* @param ev The event itself
* @param clientId ID of the client to bind for
**/
void qetesh_event_manager_RegisterEvent (QeteshEventManager* self, QeteshQEvent* ev, const gchar* clientId) {
	GeeConcurrentList* _tmp0_ = NULL;
	QeteshQEvent* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (ev != NULL);
	_tmp0_ = self->priv->EventList;
	_tmp1_ = ev;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp0_, _tmp1_);
}


/**
* Call events for the current client
* 
* If clientID is provided, call all global events plus all
* client-specific events; otherwise, just call all global events
* 
* @param clientID ID of the client
**/
void qetesh_event_manager_CallEvents (QeteshEventManager* self, const gchar* clientId) {
	const gchar* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = clientId;
	if (_tmp0_ != NULL) {
	}
	{
		GeeConcurrentList* _ev_list = NULL;
		GeeConcurrentList* _tmp1_ = NULL;
		GeeConcurrentList* _tmp2_ = NULL;
		gint _ev_size = 0;
		GeeConcurrentList* _tmp3_ = NULL;
		gint _tmp4_ = 0;
		gint _tmp5_ = 0;
		gint _ev_index = 0;
		_tmp1_ = self->priv->EventList;
		_tmp2_ = _g_object_ref0 (_tmp1_);
		_ev_list = _tmp2_;
		_tmp3_ = _ev_list;
		_tmp4_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp3_);
		_tmp5_ = _tmp4_;
		_ev_size = _tmp5_;
		_ev_index = -1;
		while (TRUE) {
			gint _tmp6_ = 0;
			gint _tmp7_ = 0;
			gint _tmp8_ = 0;
			QeteshQEvent* ev = NULL;
			GeeConcurrentList* _tmp9_ = NULL;
			gint _tmp10_ = 0;
			gpointer _tmp11_ = NULL;
			_tmp6_ = _ev_index;
			_ev_index = _tmp6_ + 1;
			_tmp7_ = _ev_index;
			_tmp8_ = _ev_size;
			if (!(_tmp7_ < _tmp8_)) {
				break;
			}
			_tmp9_ = _ev_list;
			_tmp10_ = _ev_index;
			_tmp11_ = gee_abstract_list_get ((GeeAbstractList*) _tmp9_, _tmp10_);
			ev = (QeteshQEvent*) _tmp11_;
			_qetesh_qevent_unref0 (ev);
		}
		_g_object_unref0 (_ev_list);
	}
}


static void qetesh_event_manager_class_init (QeteshEventManagerClass * klass) {
	qetesh_event_manager_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (QeteshEventManagerPrivate));
	G_OBJECT_CLASS (klass)->finalize = qetesh_event_manager_finalize;
}


static void qetesh_event_manager_instance_init (QeteshEventManager * self) {
	self->priv = QETESH_EVENT_MANAGER_GET_PRIVATE (self);
}


static void qetesh_event_manager_finalize (GObject* obj) {
	QeteshEventManager * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, QETESH_TYPE_EVENT_MANAGER, QeteshEventManager);
	_g_object_unref0 (self->priv->EventList);
	G_OBJECT_CLASS (qetesh_event_manager_parent_class)->finalize (obj);
}


/**
* Manages events for clients within and across requests
**/
GType qetesh_event_manager_get_type (void) {
	static volatile gsize qetesh_event_manager_type_id__volatile = 0;
	if (g_once_init_enter (&qetesh_event_manager_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (QeteshEventManagerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) qetesh_event_manager_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (QeteshEventManager), 0, (GInstanceInitFunc) qetesh_event_manager_instance_init, NULL };
		GType qetesh_event_manager_type_id;
		qetesh_event_manager_type_id = g_type_register_static (G_TYPE_OBJECT, "QeteshEventManager", &g_define_type_info, 0);
		g_once_init_leave (&qetesh_event_manager_type_id__volatile, qetesh_event_manager_type_id);
	}
	return qetesh_event_manager_type_id__volatile;
}



